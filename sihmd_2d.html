<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIHMD-2D IPC Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #111;
            color: #eee;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            background: rgba(0,0,0,0.75);
            border-radius: 8px;
            max-height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #panel-header {
            padding: 15px 15px 0 15px;
            flex-shrink: 0;
        }
        #panel-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        h1 {
            font-size: 1.5em;
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .tab-container {
            display: flex;
            margin-bottom: 15px;
        }
        .tab-button {
            flex: 1;
            padding: 10px;
            cursor: pointer;
            border: 1px solid #555;
            background-color: #333;
            text-align: center;
            border-bottom: 1px solid #555;
            transition: background-color 0.2s;
        }
        .tab-button.active {
            background-color: #444;
            border-bottom: 1px solid #444;
            color: #fff;
        }
        .tab-button:first-child { border-radius: 5px 0 0 5px; }
        .tab-button:last-child { border-radius: 0 5px 5px 0; }

        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .control-group {
            margin-bottom: 15px;
        }
        .control-group h3 {
            font-size: 1em;
            color: #0af;
            border-bottom: 1px solid #057;
            padding-bottom: 5px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        input[type="range"]:disabled {
            opacity: 0.5;
        }
        .button-group {
            padding: 15px;
            background: rgba(0,0,0,0.75);
            border-top: 1px solid #444;
            display: flex;
            gap: 10px;
            flex-shrink: 0;
        }
        button {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #state-counts {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.65);
            padding: 10px;
            border-radius: 8px;
        }
        #state-counts div {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
         .color-susceptible { background-color: hsl(216, 80%, 50%); } 
         .color-infectious { background-color: hsl(0, 100%, 50%); }   
         .color-hospitalized { background-color: hsl(36, 80%, 60%); } 
         .color-immune { background-color: hsl(0, 0%, 80%); }        
         .color-dead { background-color: hsl(280, 50%, 40%); }
    </style>
</head>
<body>
    <div id="controls">
        <div id="panel-header">
            <h1>SIHMD-2D IPC Simulation</h1>
            <div class="tab-container">
                <div class="tab-button active" data-tab="movement">Movement</div>
                <div class="tab-button" data-tab="infection">Infection</div>
                <div class="tab-button" data-tab="behavior">Behavior</div>
            </div>
        </div>

        <div id="panel-body">
            <div id="movement" class="tab-content active">
                 <div class="control-group">
                    <label for="latticeSize">Lattice Size: <span id="latticeSize-value">10</span></label>
                    <input type="range" id="latticeSize" min="5" max="32" value="10" step="1">
                </div>
                <div class="control-group">
                    <label for="latticeSpacing">Lattice Spacing: <span id="latticeSpacing-value">2</span></label>
                    <input type="range" id="latticeSpacing" min="1" max="4" value="2" step="0.1">
                </div>
                <div class="control-group">
                    <label for="numAgents">Number of Agents: <span id="numAgents-value">25</span></label>
                    <input type="range" id="numAgents" min="5" max="1000" value="25" step="5">
                </div>
                <div class="control-group">
                    <label for="moveRadius">Move Radius: <span id="moveRadius-value">3</span></label>
                    <input type="range" id="moveRadius" min="1" max="10" value="3" step="0.5">
                </div>
                <div class="control-group">
                    <label for="animDuration">Animation (ms): <span id="animDuration-value">3000</span></label>
                    <input type="range" id="animDuration" min="500" max="5000" value="3000" step="100">
                </div>
                <div class="control-group">
                    <label for="simInterval">Pause (ms): <span id="simInterval-value">1000</span></label>
                    <input type="range" id="simInterval" min="0" max="5000" value="1000" step="100">
                </div>
                <div class="control-group">
                    <label for="noiseFreq">Connectedness: <span id="noiseFreq-value">5.0</span></label>
                    <input type="range" id="noiseFreq" min="1.1" max="15" value="5" step="0.1">
                </div>
                <div class="control-group">
                    <label for="noiseExp">Disparity: <span id="noiseExp-value">4.0</span></label>
                    <input type="range" id="noiseExp" min="1" max="8" value="4" step="0.1">
                </div>
            </div>

            <div id="infection" class="tab-content">
                <h3>From Start</h3>
                <div class="control-group">
                    <label for="initialInfectious">Initial Infectious (%): <span id="initialInfectious-value">5</span></label>
                    <input type="range" id="initialInfectious" min="1" max="100" value="5" step="1">
                </div>

                <h3>From Susceptible</h3>
                <div class="control-group">
                    <label for="infectionProb">Event Rate / Interaction: <span id="infectionProb-value">0.5</span></label>
                    <input type="range" id="infectionProb" min="0" max="1" value="0.5" step="0.01">
                </div>
                 <div class="control-group">
                    <label>To Infected: <span id="pS_I-value">1.00</span></label>
                    <input type="range" id="pS_I" min="1" max="1" value="1" step="0.01" disabled>
                </div>

                <h3>From Infected</h3>
                 <div class="control-group">
                    <label for="infEventRate">Event Rate / Step: <span id="infEventRate-value">0.5</span></label>
                    <input type="range" id="infEventRate" min="0.01" max="1" value="0.5" step="0.01">
                </div>
                <div class="control-group">
                    <label for="pI_S">To Susceptible (pI->S): <span id="pI_S-value">0.20</span></label>
                    <input type="range" id="pI_S" min="0" max="1" value="0.20" step="0.01">
                </div>
                <div class="control-group">
                    <label for="pI_H">To Hospitalized (pI->H): <span id="pI_H-value">0.05</span></label>
                    <input type="range" id="pI_H" min="0" max="1" value="0.05" step="0.01">
                </div>
                 <div class="control-group">
                    <label for="pI_D">To Dead (pI->D): <span id="pI_D-value">0.01</span></label>
                    <input type="range" id="pI_D" min="0" max="1" value="0.01" step="0.01">
                </div>
                <div class="control-group">
                    <label for="pI_M">To Immune (pI->M): <span id="pI_M-value">0.74</span></label>
                    <input type="range" id="pI_M" min="0" max="1" value="0.74" step="0.01" disabled>
                </div>

                <h3>From Hospitalized</h3>
                <div class="control-group">
                    <label for="hospEventRate">Event Rate / Step: <span id="hospEventRate-value">0.2</span></label>
                    <input type="range" id="hospEventRate" min="0.01" max="1" value="0.2" step="0.01">
                </div>
                <div class="control-group">
                    <label for="pH_S">To Susceptible (pH->S): <span id="pH_S-value">0.25</span></label>
                    <input type="range" id="pH_S" min="0" max="1" value="0.25" step="0.01">
                </div>
                 <div class="control-group">
                    <label for="pH_D">To Dead (pH->D): <span id="pH_D-value">0.15</span></label>
                    <input type="range" id="pH_D" min="0" max="1" value="0.15" step="0.01">
                </div>
                 <div class="control-group">
                    <label for="pH_M">To Immune (pH->M): <span id="pH_M-value">0.60</span></label>
                     <input type="range" id="pH_M" min="0" max="1" value="0.60" step="0.01" disabled>
                </div>
            </div>
            
            <div id="behavior" class="tab-content">
                <p>Controls for this section will be added later.</p>
            </div>
        </div>
        
        <div class="button-group">
            <button id="startBtn">Start</button>
            <button id="togglePlayBtn" disabled>Pause</button>
        </div>
    </div>
    <div id="state-counts">
        <div><span class="color-indicator color-susceptible"></span>Susceptible: <span id="count-susceptible">0</span></div>
        <div><span class="color-indicator color-infectious"></span>Infectious: <span id="count-infectious">0</span></div>
        <div><span class="color-indicator color-hospitalized"></span>Hospitalized: <span id="count-hospitalized">0</span></div>
        <div><span class="color-indicator color-immune"></span>Immune: <span id="count-immune">0</span></div>
        <div><span class="color-indicator color-dead"></span>Dead: <span id="count-dead">0</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Core Setup ---
        let scene, camera, renderer;
        let points = [];
        let agents = [];
        let neighborMap = [];
        let simulationIntervalId;
        let isPaused = true;
        let isRunning = false;
        let config = {};
        let initialAgentCount = 0;

        // --- DOM Elements ---
        const controls = {
            latticeSize: document.getElementById('latticeSize'),
            latticeSpacing: document.getElementById('latticeSpacing'),
            numAgents: document.getElementById('numAgents'),
            moveRadius: document.getElementById('moveRadius'),
            animDuration: document.getElementById('animDuration'),
            simInterval: document.getElementById('simInterval'),
            noiseFreq: document.getElementById('noiseFreq'),
            noiseExp: document.getElementById('noiseExp'),
            initialInfectious: document.getElementById('initialInfectious'),
            infectionProb: document.getElementById('infectionProb'),
            infEventRate: document.getElementById('infEventRate'),
            pI_S: document.getElementById('pI_S'),
            pI_H: document.getElementById('pI_H'),
            pI_D: document.getElementById('pI_D'),
            hospEventRate: document.getElementById('hospEventRate'),
            pH_S: document.getElementById('pH_S'),
            pH_D: document.getElementById('pH_D'),
            startBtn: document.getElementById('startBtn'),
            togglePlayBtn: document.getElementById('togglePlayBtn')
        };
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const stateCounts = {
            susceptible: document.getElementById('count-susceptible'),
            infectious: document.getElementById('count-infectious'),
            hospitalized: document.getElementById('count-hospitalized'),
            immune: document.getElementById('count-immune'),
            dead: document.getElementById('count-dead')
        };

        /**
         * Binds all the event listeners for the UI controls.
         */
        function setupEventListeners() {
            Object.keys(controls).forEach(key => {
                if (controls[key] && controls[key].type === 'range') {
                    controls[key].addEventListener('input', () => {
                        const valueEl = document.getElementById(`${key}-value`);
                        if (valueEl) valueEl.textContent = controls[key].value;
                    });
                }
            });
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    button.classList.add('active');
                    document.getElementById(button.dataset.tab).classList.add('active');
                });
            });

            controls.startBtn.addEventListener('click', startSimulation);
            controls.togglePlayBtn.addEventListener('click', togglePlay);

            const pI_sliders = [controls.pI_S, controls.pI_H, controls.pI_D];
            pI_sliders.forEach(slider => slider.addEventListener('input', () => balanceProbabilities(pI_sliders, document.getElementById('pI_M-value'), 'pI_M')));
            
            const pH_sliders = [controls.pH_S, controls.pH_D];
            pH_sliders.forEach(slider => slider.addEventListener('input', () => balanceProbabilities(pH_sliders, document.getElementById('pH_M-value'), 'pH_M')));
            
            balanceProbabilities(pI_sliders, document.getElementById('pI_M-value'), 'pI_M');
            balanceProbabilities(pH_sliders, document.getElementById('pH_M-value'), 'pH_M');
        }

        /**
         * Ensures a set of probability sliders sums to 1.
         * @param {HTMLInputElement[]} sliders - The array of sliders to balance.
         * @param {HTMLElement} remainderEl - The element to display the remaining probability.
         * @param {string} remainderSliderId - The ID of the disabled slider to update.
         */
        function balanceProbabilities(sliders, remainderEl, remainderSliderId) {
            let total = sliders.reduce((sum, s) => sum + parseFloat(s.value), 0);
            if (total > 1) {
                const changedSlider = event.target;
                const excess = total - 1;
                let otherTotal = 0;
                sliders.forEach(s => { if (s !== changedSlider) otherTotal += parseFloat(s.value); });
                
                if (otherTotal > 0) {
                    sliders.forEach(s => {
                        if (s !== changedSlider) {
                            const proportion = parseFloat(s.value) / otherTotal;
                            s.value = parseFloat(s.value) - excess * proportion;
                            document.getElementById(`${s.id}-value`).textContent = parseFloat(s.value).toFixed(2);
                        }
                    });
                }
            }
            const remainder = 1 - sliders.reduce((sum, s) => sum + parseFloat(s.value), 0);
            const finalRemainder = Math.max(0, remainder);
            remainderEl.textContent = finalRemainder.toFixed(2);
            
            const remainderSlider = document.getElementById(remainderSliderId);
            if (remainderSlider) {
                remainderSlider.value = finalRemainder;
            }
        }

        /** Reads all values from the UI controls and stores them in the global config object. */
        function readConfig() {
            // Movement
            config.LATTICE_SIZE = parseInt(controls.latticeSize.value);
            config.LATTICE_SPACING = parseFloat(controls.latticeSpacing.value);
            config.NUM_AGENTS = parseInt(controls.numAgents.value);
            config.MOVE_RADIUS = parseFloat(controls.moveRadius.value);
            config.ANIMATION_DURATION = parseInt(controls.animDuration.value);
            config.SIMULATION_INTERVAL = parseInt(controls.simInterval.value);
            config.NOISE_FREQUENCY = parseFloat(controls.noiseFreq.value);
            config.NOISE_EXPONENT = parseFloat(controls.noiseExp.value);
            config.AGENT_SPREAD_RADIUS = 0.3;
            config.MAX_ATTRACTIVENESS = 10;
            
            // Infection
            config.INITIAL_INFECTIOUS_PERCENT = parseFloat(controls.initialInfectious.value) / 100;
            config.INFECTION_PROB = parseFloat(controls.infectionProb.value);
            config.INF_EVENT_RATE = parseFloat(controls.infEventRate.value);
            config.PI_S = parseFloat(controls.pI_S.value);
            config.PI_H = parseFloat(controls.pI_H.value);
            config.PI_D = parseFloat(controls.pI_D.value);
            config.PI_M = 1 - (config.PI_S + config.PI_H + config.PI_D);
            config.HOSP_EVENT_RATE = parseFloat(controls.hospEventRate.value);
            config.PH_S = parseFloat(controls.pH_S.value);
            config.PH_D = parseFloat(controls.pH_D.value);
            config.PH_M = 1 - (config.PH_S + config.PH_D);
        }

        /** Removes all agents and points from the scene to prepare for a restart. */
        function cleanup() {
            if (simulationIntervalId) clearInterval(simulationIntervalId);
            agents.forEach(agent => scene.remove(agent.mesh));
            points.forEach(point => scene.remove(point.mesh));
            agents = [];
            points = [];
            neighborMap = [];
        }

        /** Starts or restarts the simulation with the current UI settings. */
        function startSimulation() {
            cleanup();
            readConfig();
            
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = config.LATTICE_SIZE * config.LATTICE_SPACING;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();

            createLattice();
            precomputeNeighbors();
            createAgents();
            updateStateCounts();

            isPaused = false;
            isRunning = true;
            simulationIntervalId = setInterval(runSimulationTurn, config.SIMULATION_INTERVAL);
            
            controls.startBtn.textContent = 'Restart';
            controls.togglePlayBtn.disabled = false;
            controls.togglePlayBtn.textContent = 'Pause';
        }

        /** Initializes the THREE.js scene, camera, and renderer on page load. */
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000);
            camera.position.z = 10;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize, false);
        }

        /** Creates the lattice of points with attractiveness based on Perlin noise. */
        function createLattice() {
            const noise = getNoiseHelper();
            noise.seed(Math.random());
            const pointGeometry = new THREE.RingGeometry(0.4, 0.5, 32);

            for (let i = 0; i < config.LATTICE_SIZE; i++) {
                for (let j = 0; j < config.LATTICE_SIZE; j++) {
                    const noiseValue = noise.perlin2(i / config.NOISE_FREQUENCY, j / config.NOISE_FREQUENCY);
                    const normalizedNoise = (noiseValue + 1) / 2;
                    const skewedNoise = Math.pow(normalizedNoise, config.NOISE_EXPONENT);
                    const attractiveness = Math.max(1, 0.1 * Math.round(10 * skewedNoise * (config.MAX_ATTRACTIVENESS - 1)) + 1);
                    const x = (i - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;
                    const y = (j - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;
                    const lightness = 0.5 + 0.5 * (attractiveness / config.MAX_ATTRACTIVENESS);
                    const color = new THREE.Color().setHSL(0, 0, lightness);
                    const pointMaterial = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 });
                    const mesh = new THREE.Mesh(pointGeometry, pointMaterial);
                    mesh.position.set(x, y, 0);
                    mesh.scale.set(attractiveness * 0.5, attractiveness * 0.5, 1);
                    scene.add(mesh);
                    points.push({ x, y, attractiveness, mesh, index: points.length });
                }
            }
        }

        /** Pre-calculates which points are within the move radius for every other point. */
        function precomputeNeighbors() {
            const maxDistance = config.MOVE_RADIUS * config.LATTICE_SPACING;
            for (let i = 0; i < points.length; i++) {
                const currentPoint = points[i];
                const nearbyPoints = [];
                for (let j = 0; j < points.length; j++) {
                    const otherPoint = points[j];
                    const distance = currentPoint.mesh.position.distanceTo(otherPoint.mesh.position);
                    if (distance <= maxDistance) {
                        nearbyPoints.push(otherPoint);
                    }
                }
                neighborMap[i] = nearbyPoints;
            }
        }

        /** Creates the agents, sets their initial state, and infects a percentage of them. */
        function createAgents() {
            initialAgentCount = config.NUM_AGENTS;
            const agentGeometry = new THREE.CircleGeometry(0.15, 16);
            for (let i = 0; i < config.NUM_AGENTS; i++) {
                const agentMaterial = new THREE.MeshBasicMaterial({ color: getAgentColor('susceptible')});
                const startPointIndex = Math.floor(Math.random() * points.length);
                const startPoint = points[startPointIndex];
                const mesh = new THREE.Mesh(agentGeometry, agentMaterial);
                mesh.position.copy(startPoint.mesh.position);
                scene.add(mesh);
                agents.push({ id: i, state: 'susceptible', currentPointIndex: startPointIndex, mesh, isMoving: false, moveStartTime: 0, startPosition: new THREE.Vector3(), endPosition: new THREE.Vector3() });
            }

            const numToInfect = Math.floor(config.NUM_AGENTS * config.INITIAL_INFECTIOUS_PERCENT);
            for (let i = 0; i < numToInfect; i++) {
                agents[i].state = 'infectious';
            }
        }

        /** The main simulation turn logic, running disease and movement logic sequentially. */
        function runSimulationTurn() {
            if (agents.some(a => a.isMoving)) return;

            // Phase A: Disease and State Changes at rest
            const agentsByPoint = {};
            agents.forEach(agent => {
                if (!agentsByPoint[agent.currentPointIndex]) {
                    agentsByPoint[agent.currentPointIndex] = [];
                }
                agentsByPoint[agent.currentPointIndex].push(agent);
            });
            
            Object.values(agentsByPoint).forEach(group => {
                const infectiousCount = group.filter(a => a.state === 'infectious').length;
                if (infectiousCount > 0) {
                    group.forEach(agent => {
                        if (agent.state === 'susceptible' && Math.random() < config.INFECTION_PROB) {
                            agent.state = 'infectious';
                        }
                    });
                }
            });

            const agentsToRemove = new Set();
            agents.forEach(agent => {
                if (agent.state === 'infectious' && Math.random() < config.INF_EVENT_RATE) {
                    agent.state = determineNextState('infectious');
                } else if (agent.state === 'hospitalized' && Math.random() < config.HOSP_EVENT_RATE) {
                    agent.state = determineNextState('hospitalized');
                }

                if (agent.state === 'dead') agentsToRemove.add(agent);
            });

            // Phase B: Plan and Initiate Movement
            agents.forEach(agent => {
                if (agent.state === 'dead') return;
                agent.mesh.material.color.set(getAgentColor(agent.state));
                if (agent.state !== 'hospitalized') moveAgent(agent);
            });

            if (agentsToRemove.size > 0) {
                agentsToRemove.forEach(agent => scene.remove(agent.mesh));
                agents = agents.filter(a => !agentsToRemove.has(a));
            }
            
            updateStateCounts();
        }

        /** Determines the next state for an agent based on configured probabilities. */
        function determineNextState(currentState) {
            const r = Math.random();
            if (currentState === 'infectious') {
                if (r < config.PI_S) return 'susceptible';
                if (r < config.PI_S + config.PI_H) return 'hospitalized';
                if (r < config.PI_S + config.PI_H + config.PI_D) return 'dead';
                return 'immune';
            }
            if (currentState === 'hospitalized') {
                if (r < config.PH_S) return 'susceptible';
                if (r < config.PH_S + config.PH_D) return 'dead';
                return 'immune';
            }
            return currentState;
        }

        /** Calculates the next destination for an agent and initiates its movement. */
        function moveAgent(agent) {
             const potentialDestinations = neighborMap[agent.currentPointIndex];
            if (!potentialDestinations || potentialDestinations.length === 0) return;
            
            const weightedDestinations = [];
            let totalRelativeAttractiveness = 0;
            potentialDestinations.forEach(point => {
                const distance = points[agent.currentPointIndex].mesh.position.distanceTo(point.mesh.position);
                const isStationary = distance < 0.01;
                const relativeAttractiveness = isStationary ? 0 : point.attractiveness / Math.max(0.001, Math.pow(distance, 2));
                weightedDestinations.push({ point, relativeAttractiveness });
                totalRelativeAttractiveness += relativeAttractiveness;
            });

            let randomValue = Math.random() * totalRelativeAttractiveness;
            let chosenDestination = potentialDestinations[0]; 
            for (const dest of weightedDestinations) {
                randomValue -= dest.relativeAttractiveness;
                if (randomValue <= 0) {
                    chosenDestination = dest.point;
                    break;
                }
            }

            const targetPosition = chosenDestination.mesh.position.clone();
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * config.AGENT_SPREAD_RADIUS;
            targetPosition.x += Math.cos(angle) * radius;
            targetPosition.y += Math.sin(angle) * radius;

            agent.isMoving = true;
            agent.moveStartTime = performance.now();
            agent.startPosition.copy(agent.mesh.position);
            agent.endPosition.copy(targetPosition);
            agent.currentPointIndex = chosenDestination.index;
        }

        /** Returns the appropriate THREE.Color for an agent's state. */
        function getAgentColor(state) {
            switch(state) {
                case 'susceptible': return new THREE.Color('hsl(216, 80%, 50%)');
                case 'infectious': return new THREE.Color('hsl(0, 100%, 50%)');
                case 'hospitalized': return new THREE.Color('hsl(36, 80%, 60%)');
                case 'immune': return new THREE.Color('hsl(0, 0%, 80%)');
                default: return new THREE.Color('black');
            }
        }
        
        /** The main animation loop, which runs every frame to render the scene. */
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            agents.forEach(agent => {
                if (agent.isMoving) {
                    const elapsedTime = now - agent.moveStartTime;
                    const progress = Math.min(elapsedTime / config.ANIMATION_DURATION, 1.0);
                    const easedProgress = progress * progress * (3 - 2 * progress);
                    agent.mesh.position.lerpVectors(agent.startPosition, agent.endPosition, easedProgress);
                    if (progress >= 1.0) {
                        agent.isMoving = false;
                        agent.mesh.position.copy(agent.endPosition);
                    }
                }
            });
            renderer.render(scene, camera);
        }

        /** Updates the state counters in the UI legend. */
        function updateStateCounts() {
            const counts = { susceptible: 0, infectious: 0, hospitalized: 0, immune: 0 };
            agents.forEach(agent => {
                if (counts[agent.state] !== undefined) {
                    counts[agent.state]++;
                }
            });
            stateCounts.susceptible.textContent = counts.susceptible;
            stateCounts.infectious.textContent = counts.infectious;
            stateCounts.hospitalized.textContent = counts.hospitalized;
            stateCounts.immune.textContent = counts.immune;
            stateCounts.dead.textContent = initialAgentCount - agents.length;
        }

        /** Handles window resizing to keep the camera and renderer updated. */
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            const frustumSize = (config && config.LATTICE_SIZE) ? config.LATTICE_SIZE * config.LATTICE_SPACING : 20;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        /** Toggles the paused state of the simulation. */
        function togglePlay() {
            if (!isRunning) return;
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(simulationIntervalId);
                controls.togglePlayBtn.textContent = "Resume";
            } else {
                simulationIntervalId = setInterval(runSimulationTurn, config.SIMULATION_INTERVAL);
                controls.togglePlayBtn.textContent = "Pause";
            }
        }

        /** Generates Perlin noise values for creating the attractiveness landscape. */
        function getNoiseHelper() {
            class Grad { constructor(x, y, z) { this.x = x; this.y = y; this.z = z; } dot2(x, y) { return this.x * x + this.y * y; } }
            const grad3 = [ new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1) ];
            const p = [ 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180 ];
            let perm = new Array(512), gradP = new Array(512);
            function seed(s) { if(s>0&&s<1)s*=65536; s=Math.floor(s); if(s<256)s|=s<<8; for(let i=0;i<256;i++){let v=(i&1)?p[i]^(s&255):p[i]^((s>>8)&255);perm[i]=perm[i+256]=v;gradP[i]=gradP[i+256]=grad3[v%12]}}
            seed(0);
            function fade(t){return t*t*t*(t*(t*6-15)+10)} function lerp(a,b,t){return(1-t)*a+t*b}
            function perlin2(x, y) { let X=Math.floor(x),Y=Math.floor(y);x=x-X;y=y-Y;X=X&255;Y=Y&255;let n00=gradP[X+perm[Y]].dot2(x,y);let n01=gradP[X+perm[Y+1]].dot2(x,y-1);let n10=gradP[X+1+perm[Y]].dot2(x-1,y);let n11=gradP[X+1+perm[Y+1]].dot2(x-1,y-1);let u=fade(x);return lerp(lerp(n00,n10,u),lerp(n01,n11,u),fade(y))}
            return { seed, perlin2 };
        }

        // --- Start Application ---
        init();
        setupEventListeners();
        animate();

    </script>
</body>
</html>
