<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIHMD-2D IPC Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #111;
            color: #eee;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            background: rgba(0,0,0,0.65);
            border-radius: 8px;
            max-height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #panel-header {
            padding: 15px 15px 0 15px;
        }
        #panel-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        h1 {
            font-size: 1.5em;
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .tab-container {
            display: flex;
            margin-bottom: 15px;
        }
        .tab-button {
            flex: 1;
            padding: 10px;
            cursor: pointer;
            border: 1px solid #555;
            background-color: #333;
            text-align: center;
            border-bottom: 1px solid #555;
            transition: background-color 0.2s;
        }
        .tab-button.active {
            background-color: #444;
            border-bottom: 1px solid #444;
            color: #fff;
        }
        .tab-button:first-child { border-radius: 5px 0 0 5px; }
        .tab-button:last-child { border-radius: 0 5px 5px 0; }

        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .control-group {
            margin-bottom: 12px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .control-group input[type="range"] {
            width: 100%;
        }
        .button-group {
            padding: 15px;
            background: rgba(0,0,0,0.65);
            border-top: 1px solid #444;
            display: flex;
            gap: 10px;
        }
        button {
            flex-grow: 1;
            padding: 10px 15px;
            border-radius: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="controls">
        <div id="panel-header">
            <h1>SIHMD-2D IPC Simulation</h1>
            <div class="tab-container">
                <div class="tab-button active" data-tab="movement">Movement</div>
                <div class="tab-button" data-tab="infection">Infection Transfer</div>
                <div class="tab-button" data-tab="behavior">Human Behavior</div>
            </div>
        </div>

        <div id="panel-body">
            <div id="movement" class="tab-content active">
                <div class="control-group">
                    <label for="latticeSize">Lattice Size: <span id="latticeSize-value">10</span></label>
                    <input type="range" id="latticeSize" min="5" max="32" value="10" step="1">
                </div>
                <div class="control-group">
                    <label for="latticeSpacing">Lattice Spacing: <span id="latticeSpacing-value">2</span></label>
                    <input type="range" id="latticeSpacing" min="1" max="4" value="2" step="0.1">
                </div>
                <div class="control-group">
                    <label for="numAgents">Number of Agents: <span id="numAgents-value">25</span></label>
                    <input type="range" id="numAgents" min="5" max="1000" value="25" step="5">
                </div>
                <div class="control-group">
                    <label for="moveRadius">Move Radius: <span id="moveRadius-value">3</span></label>
                    <input type="range" id="moveRadius" min="1" max="10" value="3" step="0.5">
                </div>
                <div class="control-group">
                    <label for="stationaryMult">Stationary Multiplier: <span id="stationaryMult-value">0.2</span></label>
                    <input type="range" id="stationaryMult" min="0" max="2" value="0.2" step="0.05">
                </div>
                <div class="control-group">
                    <label for="animDuration">Animation (ms): <span id="animDuration-value">3000</span></label>
                    <input type="range" id="animDuration" min="1" max="5000" value="3000" step="100">
                </div>
                <div class="control-group">
                    <label for="simInterval">Pause (ms): <span id="simInterval-value">1000</span></label>
                    <input type="range" id="simInterval" min="0" max="5000" value="1000" step="100">
                </div>
                <div class="control-group">
                    <label for="noiseFreq">Connectedness: <span id="noiseFreq-value">5.0</span></label>
                    <input type="range" id="noiseFreq" min="1.1" max="15" value="5" step="0.1">
                </div>
                <div class="control-group">
                    <label for="noiseExp">Disparity: <span id="noiseExp-value">4.0</span></label>
                    <input type="range" id="noiseExp" min="1" max="8" value="4" step="0.1">
                </div>
            </div>

            <div id="infection" class="tab-content">
                <p>Coming Soon...</p>
            </div>
            
            <div id="behavior" class="tab-content">
                <p>Coming Soon...</p>
            </div>
        </div>
        
        <div class="button-group">
            <button id="startBtn">Start</button>
            <button id="togglePlayBtn" disabled>Pause</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // Setup 
        let scene, camera, renderer;
        let points = [];
        let agents = [];
        let neighborMap = [];
        let simulationIntervalId;
        let isPaused = true; // Start paused by default
        let isRunning = false;
        let config = {};

        // DOM Elements
        const controls = {
            latticeSize: document.getElementById('latticeSize'),
            latticeSpacing: document.getElementById('latticeSpacing'),
            numAgents: document.getElementById('numAgents'),
            moveRadius: document.getElementById('moveRadius'),
            stationaryMult: document.getElementById('stationaryMult'),
            animDuration: document.getElementById('animDuration'),
            simInterval: document.getElementById('simInterval'),
            noiseFreq: document.getElementById('noiseFreq'),
            noiseExp: document.getElementById('noiseExp'),
            startBtn: document.getElementById('startBtn'),
            togglePlayBtn: document.getElementById('togglePlayBtn')
        };
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');

        // Event Listeners
        Object.keys(controls).forEach(key => {
            if (controls[key].type === 'range') {
                controls[key].addEventListener('input', () => {
                    document.getElementById(`${key}-value`).textContent = controls[key].value;
                });
            }
        });
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                tabButtons.forEach(btn => btn.classList.remove('active'));
                tabContents.forEach(content => content.classList.remove('active'));
                
                button.classList.add('active');
                document.getElementById(button.dataset.tab).classList.add('active');
            });
        });
        controls.startBtn.addEventListener('click', startSimulation);
        controls.togglePlayBtn.addEventListener('click', togglePlay);

        // Update Settings
        function readConfig() {
            config.LATTICE_SIZE = parseInt(controls.latticeSize.value);
            config.LATTICE_SPACING = parseFloat(controls.latticeSpacing.value);
            config.NUM_AGENTS = parseInt(controls.numAgents.value);
            config.MOVE_RADIUS = parseFloat(controls.moveRadius.value);
            config.STATIONARY_MULT = parseFloat(controls.stationaryMult.value);
            config.ANIMATION_DURATION = parseInt(controls.animDuration.value);
            config.SIMULATION_INTERVAL = parseInt(controls.simInterval.value);
            config.NOISE_FREQUENCY = parseFloat(controls.noiseFreq.value);
            config.NOISE_EXPONENT = parseFloat(controls.noiseExp.value);
            config.AGENT_SPREAD_RADIUS = 0.3;
            config.MAX_ATTRACTIVENESS = 10;
        }
        function cleanup() {
            if (simulationIntervalId) clearInterval(simulationIntervalId);
            agents.forEach(agent => scene.remove(agent.mesh));
            points.forEach(point => scene.remove(point.mesh));
            agents = [];
            points = [];
            neighborMap = [];
        }

        // Launch
        function startSimulation() {
            cleanup();
            readConfig();
            
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = config.LATTICE_SIZE * config.LATTICE_SPACING;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();

            createLattice();
            precomputeNeighbors();
            createAgents();

            isPaused = false;
            isRunning = true;
            simulationIntervalId = setInterval(simulationStep, config.SIMULATION_INTERVAL);
            
            controls.startBtn.textContent = 'Restart';
            controls.togglePlayBtn.disabled = false;
            controls.togglePlayBtn.textContent = 'Pause';
        }

        // Initialize Animation and Rendering
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000);
            camera.position.z = 10;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize, false);
        }

        // Construct a NxN lattice of points with "random" attractiveness
        function createLattice() {
            const noise = getNoiseHelper();
            noise.seed(Math.random());
            const pointGeometry = new THREE.RingGeometry(0.4, 0.5, 32);

            // Loops to create each point
            for (let i = 0; i < config.LATTICE_SIZE; i++) {
                for (let j = 0; j < config.LATTICE_SIZE; j++) {
                    
                    // Using perlin noise generation, create pseudorandom value
                    const noiseValue = noise.perlin2(i / config.NOISE_FREQUENCY, j / config.NOISE_FREQUENCY);
                    const normalizedNoise = (noiseValue + 1) / 2;
                    
                    // Map this number to a modified exponential distribution for attractiveness
                    const skewedNoise = Math.pow(normalizedNoise, config.NOISE_EXPONENT);
                    const attractiveness = Math.max(1, 0.1 * Math.round(10 * skewedNoise * (config.MAX_ATTRACTIVENESS - 1)) + 1);

                    const x = (i - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;
                    const y = (j - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;

                    // Create the point and animate it, with size and color corresponding to attractiveness
                    const lightness = 0.5 + 0.5 * (attractiveness / config.MAX_ATTRACTIVENESS);
                    const color = new THREE.Color().setHSL(0, 0, lightness);
                    const pointMaterial = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.8 });
                    const mesh = new THREE.Mesh(pointGeometry, pointMaterial);
                    mesh.position.set(x, y, 0);
                    mesh.scale.set(attractiveness * 0.5, attractiveness * 0.5, 1);
                    scene.add(mesh);

                    points.push({ x, y, attractiveness, mesh, index: points.length });
                }
            }
        }

        // To speed up computation for large simulations, create a lookup table of each point's neighbors based on the move radius
        function precomputeNeighbors() {
            const maxDistance = config.MOVE_RADIUS * config.LATTICE_SPACING;
            for (let i = 0; i < points.length; i++) {
                const currentPoint = points[i];
                const nearbyPoints = [];
                for (let j = 0; j < points.length; j++) {
                    const otherPoint = points[j];
                    const distance = currentPoint.mesh.position.distanceTo(otherPoint.mesh.position);
                    if (distance <= maxDistance) {
                        nearbyPoints.push(otherPoint);
                    }
                }
                neighborMap[i] = nearbyPoints;
            }
        }

        // Create all the agents and add them to the animation scene
        function createAgents() {
            const agentGeometry = new THREE.CircleGeometry(0.15, 16);
            for (let i = 0; i < config.NUM_AGENTS; i++) {
                // For now, use a random color, but this will correspond to the compartment the agent is in (SIHMD)
                const agentMaterial = new THREE.MeshBasicMaterial({ color: new THREE.Color().setHSL(i / config.NUM_AGENTS, 0.9, 0.6) });
                const startPointIndex = Math.floor(Math.random() * points.length);
                const startPoint = points[startPointIndex];
                const mesh = new THREE.Mesh(agentGeometry, agentMaterial);
                mesh.position.copy(startPoint.mesh.position);
                scene.add(mesh);
                agents.push({ id: i, currentPointIndex: startPointIndex, mesh, isMoving: false, moveStartTime: 0, startPosition: new THREE.Vector3(), endPosition: new THREE.Vector3() });
            }
        }

        // The most important part, performing one simulation step
        function simulationStep() {
            
            // Repeat for every agent
            agents.forEach(agent => {
                if (agent.isMoving) return;
                
                // Get the predetermined lookup table of nearby points to consider
                const potentialDestinations = neighborMap[agent.currentPointIndex];
                if (!potentialDestinations || potentialDestinations.length === 0) return;
                const currentPoint = points[agent.currentPointIndex];
                const weightedDestinations = [];
                let totalRelativeAttractiveness = 0;
                
                // Find the relative attractiveness of each potential point to the current agent
                potentialDestinations.forEach(point => {
                    const distance = currentPoint.mesh.position.distanceTo(point.mesh.position);
                    const isStationary = distance < 0.5;
                    
                    // The agent considers staying still based on the provided multiplier in settings
                    // All the other points have the RA calculated with inverse square law and their absolute attractiveness
                    const relativeAttractiveness = isStationary ? point.attractiveness * config.STATIONARY_MULT : point.attractiveness / Math.pow(distance, 2);
                    weightedDestinations.push({ point, relativeAttractiveness });
                    totalRelativeAttractiveness += relativeAttractiveness;
                });
                
                // Choose a random point weighted by RA
                let randomValue = Math.random() * totalRelativeAttractiveness;
                let chosenDestination = weightedDestinations[weightedDestinations.length - 1].point;
                for (let i = 0; i < weightedDestinations.length; i++) {
                    randomValue -= weightedDestinations[i].relativeAttractiveness;
                    if (randomValue <= 0) {
                        chosenDestination = weightedDestinations[i].point;
                        break;
                    }
                }
                
                // Move the agent to the next point
                const targetPosition = chosenDestination.mesh.position.clone();
                const angle = Math.random() * 2 * Math.PI;
                const radius = Math.random() * config.AGENT_SPREAD_RADIUS;
                targetPosition.x += Math.cos(angle) * radius;
                targetPosition.y += Math.sin(angle) * radius;
                agent.isMoving = true;
                agent.moveStartTime = performance.now();
                agent.startPosition.copy(agent.mesh.position);
                agent.endPosition.copy(targetPosition);
                agent.currentPointIndex = chosenDestination.index;
            });
        }

        // Using three.js, smoothly animate all actions in the scene
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            agents.forEach(agent => {
                if (agent.isMoving) {
                    const elapsedTime = now - agent.moveStartTime;
                    const progress = Math.min(elapsedTime / config.ANIMATION_DURATION, 1.0);
                    const easedProgress = progress * progress * (3 - 2 * progress);
                    agent.mesh.position.lerpVectors(agent.startPosition, agent.endPosition, easedProgress);
                    if (progress >= 1.0) {
                        agent.isMoving = false;
                        agent.mesh.position.copy(agent.endPosition);
                    }
                }
            });
            renderer.render(scene, camera);
        }

        // Ensure the simulation still works if the window size is changed
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            const frustumSize = (config && config.LATTICE_SIZE) ? config.LATTICE_SIZE * config.LATTICE_SPACING : 20;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Clicking pause/play lets the animation finish but toggles next steps
        function togglePlay() {
            if (!isRunning) return;
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(simulationIntervalId);
                controls.togglePlayBtn.textContent = "Resume";
            } else {
                simulationIntervalId = setInterval(simulationStep, config.SIMULATION_INTERVAL);
                controls.togglePlayBtn.textContent = "Pause";
            }
        }

        // Perlin Noise generating function
        // I cannot comprehend how this works, it is very advanced. I got it from https://github.com/josephg/noisejs
        function getNoiseHelper() {
            class Grad { constructor(x, y, z) { this.x = x; this.y = y; this.z = z; } dot2(x, y) { return this.x * x + this.y * y; } }
            const grad3 = [ new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1) ];
            const p = [ 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180 ];
            let perm = new Array(512), gradP = new Array(512);
            function seed(s) { if(s>0&&s<1)s*=65536; s=Math.floor(s); if(s<256)s|=s<<8; for(let i=0;i<256;i++){let v=(i&1)?p[i]^(s&255):p[i]^((s>>8)&255);perm[i]=perm[i+256]=v;gradP[i]=gradP[i+256]=grad3[v%12]}}
            seed(0);
            function fade(t){return t*t*t*(t*(t*6-15)+10)} function lerp(a,b,t){return(1-t)*a+t*b}
            function perlin2(x, y) { let X=Math.floor(x),Y=Math.floor(y);x=x-X;y=y-Y;X=X&255;Y=Y&255;let n00=gradP[X+perm[Y]].dot2(x,y);let n01=gradP[X+perm[Y+1]].dot2(x,y-1);let n10=gradP[X+1+perm[Y]].dot2(x-1,y);let n11=gradP[X+1+perm[Y+1]].dot2(x-1,y-1);let u=fade(x);return lerp(lerp(n00,n10,u),lerp(n01,n11,u),fade(y))}
            return { seed, perlin2 };
        }

        // Start Animation
        init();
        animate();
    </script>
</body>
</html>
