<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIHMD-2D IPC Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: #111;
            color: #eee;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 300px;
            background: rgba(0,0,0,0.75);
            border-radius: 8px;
            max-height: calc(100vh - 20px);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #panel-header {
            padding: 15px 15px 0 15px;
            flex-shrink: 0;
        }
        #panel-body {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        h1 {
            font-size: 1.5em;
            margin-top: 0;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }
        .tab-container {
            display: flex;
            margin-bottom: 15px;
        }
        .tab-button {
            flex: 1;
            padding: 10px;
            cursor: pointer;
            border: 1px solid #555;
            background-color: #333;
            text-align: center;
            border-bottom: 1px solid #555;
            transition: background-color 0.2s;
        }
        .tab-button.active {
            background-color: #444;
            border-bottom: 1px solid #444;
            color: #fff;
        }
        .tab-button:first-child { border-radius: 5px 0 0 5px; }
        .tab-button:last-child { border-radius: 0 5px 5px 0; }

        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        .control-group {
            margin-bottom: 15px;
        }
        .control-group h3 {
            font-size: 1em;
            color: #0af;
            border-bottom: 1px solid #057;
            padding-bottom: 5px;
            margin-top: 15px;
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            cursor: help;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #444;
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .control-group input[type="range"]:hover {
            opacity: 1;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
        }
        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #007bff;
            cursor: pointer;
            border: none;
        }

        /* Colored Sliders */
        .control-group input.slider-susceptible::-webkit-slider-thumb { background: hsl(216, 80%, 50%); }
        .control-group input.slider-infectious::-webkit-slider-thumb { background: hsl(0, 100%, 50%); }
        .control-group input.slider-hospitalized::-webkit-slider-thumb { background: hsl(36, 80%, 60%); }
        .control-group input.slider-immune::-webkit-slider-thumb { background: hsl(0, 0%, 80%); }
        .control-group input.slider-dead::-webkit-slider-thumb { background: hsl(280, 50%, 40%); }

        .control-group input.slider-susceptible::-moz-range-thumb { background: hsl(216, 80%, 50%); }
        .control-group input.slider-infectious::-moz-range-thumb { background: hsl(0, 100%, 50%); }
        .control-group input.slider-hospitalized::-moz-range-thumb { background: hsl(36, 80%, 60%); }
        .control-group input.slider-immune::-moz-range-thumb { background: hsl(0, 0%, 80%); }
        .control-group input.slider-dead::-moz-range-thumb { background: hsl(280, 50%, 40%); }

        input[type="range"]:disabled {
            opacity: 0.5;
        }
        .button-group {
            padding: 15px;
            background: rgba(0,0,0,0.75);
            border-top: 1px solid #444;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            flex-shrink: 0;
        }
        button {
            flex: 1 1 45%;
            padding: 10px 15px;
            border-radius: 5px;
            border: none;
            background-color: #007bff;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: background-color 0.2s;
        }
        #exportBtn {
            flex-basis: 100%;
            background-color: #1a8e5f;
        }
        #exportBtn:hover {
             background-color: #177d54;
        }

        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #state-counts {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.65);
            padding: 10px;
            border-radius: 8px;
        }
        #state-counts div {
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .color-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
         .color-susceptible { background-color: hsl(216, 80%, 50%); } 
         .color-infectious { background-color: hsl(0, 100%, 50%); }   
         .color-hospitalized { background-color: hsl(36, 80%, 60%); } 
         .color-immune { background-color: hsl(0, 0%, 80%); }        
         .color-dead { background-color: hsl(280, 50%, 40%); }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal {
            background: #222;
            padding: 25px;
            border-radius: 10px;
            width: 400px;
            text-align: center;
        }
        .modal h2 {
            margin-top: 0;
        }
        .modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }
        #progressBarContainer {
            width: 100%;
            background-color: #555;
            border-radius: 5px;
            margin: 15px 0;
        }
        #progressBar {
            width: 0%;
            height: 20px;
            background-color: #1a8e5f;
            border-radius: 5px;
            text-align: center;
            line-height: 20px;
            color: white;
            transition: width 0.3s ease;
        }
        /* Toggle Switch */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 150px;
            margin: 0 auto;
        }
        .toggle-label {
            display: flex;
            background: #333;
            border: 1px solid #555;
            border-radius: 20px;
            cursor: pointer;
            padding: 4px;
        }
        .toggle-input {
            display: none;
        }
        .toggle-text {
            flex: 1;
            text-align: center;
            padding: 4px;
            border-radius: 20px;
            color: #aaa;
            transition: all 0.2s ease-in-out;
        }
        .toggle-input:checked + .toggle-label .right {
            background: #007bff;
            color: white;
        }
        .toggle-input:not(:checked) + .toggle-label .left {
            background: #007bff;
            color: white;
        }

    </style>
</head>
<body>
    <div id="controls">
        <div id="panel-header">
            <h1>SIHMD-2D IPC Simulation</h1>
            <div class="tab-container">
                <div class="tab-button active" data-tab="movement">Movement</div>
                <div class="tab-button" data-tab="infection">Infection</div>
                <div class="tab-button" data-tab="behavior">Behavior</div>
            </div>
        </div>

        <div id="panel-body">
            <div id="movement" class="tab-content active">
                 <div class="control-group">
                    <label for="latticeSize" title="The size of the square grid (e.g., 10x10). Larger grids require more processing.">Lattice Size: <span id="latticeSize-value">18</span></label>
                    <input type="range" id="latticeSize" min="5" max="32" value="18" step="1">
                </div>
                <div class="control-group">
                    <label for="latticeSpacing" title="The distance between the centers of adjacent points on the grid.">Lattice Spacing: <span id="latticeSpacing-value">2</span></label>
                    <input type="range" id="latticeSpacing" min="1" max="4" value="2" step="0.1">
                </div>
                <div class="control-group">
                    <label for="numAgents" title="The total number of agents (people) in the simulation.">Number of Agents: <span id="numAgents-value">320</span></label>
                    <input type="range" id="numAgents" min="5" max="1000" value="320" step="5">
                </div>
                <div class="control-group">
                    <label for="moveRadius" title="How many lattice spaces away an agent can consider moving to.">Move Radius: <span id="moveRadius-value">3</span></label>
                    <input type="range" id="moveRadius" min="1" max="10" value="3" step="0.5">
                </div>
                <div class="control-group">
                    <label for="stayMultiplier" title="A multiplier for the attractiveness of an agent's current location. Higher values make agents more likely to stay put.">Stay Multiplier: <span id="stayMultiplier-value">0.5</span></label>
                    <input type="range" id="stayMultiplier" min="0" max="4" value="0.5" step="0.1">
                </div>
                <div class="control-group">
                    <label for="animDuration" title="How long the movement animation takes in milliseconds.">Animation (ms): <span id="animDuration-value">2000</span></label>
                    <input type="range" id="animDuration" min="500" max="5000" value="2000" step="100">
                </div>
                <div class="control-group">
                    <label for="simInterval" title="The delay in milliseconds between simulation turns. This is the 'rest' time after all animations finish.">Pause (ms): <span id="simInterval-value">1000</span></label>
                    <input type="range" id="simInterval" min="0" max="5000" value="1000" step="100">
                </div>
                <div class="control-group">
                    <label for="noiseFreq" title="Controls the size of the attractiveness 'continents'. Lower values create larger, more connected areas.">Connectedness: <span id="noiseFreq-value">5.0</span></label>
                    <input type="range" id="noiseFreq" min="1.1" max="15" value="5" step="0.1">
                </div>
                <div class="control-group">
                    <label for="noiseExp" title="Controls the distribution of attractiveness. Higher values create more low-attractiveness points with sparse, high-value peaks.">Disparity: <span id="noiseExp-value">4.0</span></label>
                    <input type="range" id="noiseExp" min="1" max="8" value="4" step="0.1">
                </div>
            </div>

            <div id="infection" class="tab-content">
                <h3>From Start</h3>
                <div class="control-group">
                    <label for="initialInfectious" title="The percentage of the total population that will start in the 'Infectious' state.">Initial Infectious (%): <span id="initialInfectious-value">2</span></label>
                    <input type="range" id="initialInfectious" min="0.1" max="10" value="2" step="0.1">
                </div>

                <h3>From Susceptible</h3>
                <div class="control-group">
                    <label for="infectionProb" title="The base probability that a susceptible agent will become infected if they are at the same location as an infectious agent.">Event Rate / Interaction: <span id="infectionProb-value">0.15</span></label>
                    <input type="range" id="infectionProb" min="0" max="1" value="0.15" step="0.01">
                </div>
                 <div class="control-group">
                    <label title="Susceptible agents can only become infected.">To Infected: <span id="pS_I-value">1.00</span></label>
                    <input type="range" id="pS_I" min="0" max="1" value="1" step="0.01" disabled class="slider-infectious">
                </div>

                <h3>From Infected</h3>
                 <div class="control-group">
                    <label for="infEventRate" title="The probability that an infectious agent will change state during a simulation step.">Event Rate / Step: <span id="infEventRate-value">0.07</span></label>
                    <input type="range" id="infEventRate" min="0.01" max="1" value="0.07" step="0.01">
                </div>
                <div class="control-group">
                    <label for="pI_S" title="Given a state change event, the probability of transitioning from Infectious to Susceptible.">To Susceptible: <span id="pI_S-value">0.74</span></label>
                    <input type="range" id="pI_S" min="0" max="1" value="0.74" step="0.01" class="slider-susceptible">
                </div>
                <div class="control-group">
                    <label for="pI_H" title="Given a state change event, the probability of transitioning from Infectious to Hospitalized.">To Hospitalized: <span id="pI_H-value">0.05</span></label>
                    <input type="range" id="pI_H" min="0" max="1" value="0.05" step="0.01" class="slider-hospitalized">
                </div>
                 <div class="control-group">
                    <label for="pI_D" title="Given a state change event, the probability of transitioning from Infectious to Dead.">To Dead: <span id="pI_D-value">0.003</span></label>
                    <input type="range" id="pI_D" min="0" max="0.1" value="0.003" step="0.001" class="slider-dead">
                </div>
                <div class="control-group">
                    <label for="pI_M" title="This value is automatically calculated to ensure all probabilities sum to 1.">To Immune: <span id="pI_M-value">0.207</span></label>
                    <input type="range" id="pI_M" min="0" max="1" value="0.207" step="0.001" disabled class="slider-immune">
                </div>

                <h3>From Hospitalized</h3>
                <div class="control-group">
                    <label for="hospEventRate" title="The probability that a hospitalized agent will change state during a simulation step.">Event Rate / Step: <span id="hospEventRate-value">0.14</span></label>
                    <input type="range" id="hospEventRate" min="0.01" max="1" value="0.14" step="0.01">
                </div>
                <div class="control-group">
                    <label for="pH_S" title="Given a state change event, the probability of transitioning from Hospitalized to Susceptible.">To Susceptible: <span id="pH_S-value">0.25</span></label>
                    <input type="range" id="pH_S" min="0" max="1" value="0.25" step="0.01" class="slider-susceptible">
                </div>
                 <div class="control-group">
                    <label for="pH_D" title="Given a state change event, the probability of transitioning from Hospitalized to Dead.">To Dead: <span id="pH_D-value">0.15</span></label>
                    <input type="range" id="pH_D" min="0" max="1" value="0.15" step="0.01" class="slider-dead">
                </div>
                 <div class="control-group">
                    <label for="pH_M" title="This value is automatically calculated to ensure all probabilities sum to 1.">To Immune: <span id="pH_M-value">0.60</span></label>
                     <input type="range" id="pH_M" min="0" max="1" value="0.60" step="0.01" disabled class="slider-immune">
                </div>
                
                <h3>From Immune</h3>
                <div class="control-group">
                    <label for="immunityDuration" title="The average number of days (steps) an agent remains immune before becoming susceptible again. Uses a Poisson distribution for variability.">Avg. Immunity Duration (days): <span id="immunityDuration-value">270</span></label>
                    <input type="range" id="immunityDuration" min="10" max="365" value="270" step="1">
                </div>

                <h3>Variant Emergence</h3>
                 <div class="control-group">
                    <label for="enableVariant">Enable Variant:</label>
                    <input type="checkbox" id="enableVariant" checked>
                </div>
                <div class="control-group">
                    <label for="variantDay" title="The day (step) on which the new, more contagious variant emerges.">Emergence Day: <span id="variantDay-value">630</span></label>
                    <input type="range" id="variantDay" min="50" max="1000" value="630" step="1">
                </div>
                <div class="control-group">
                    <label for="variantContagionIncrease" title="The percentage by which the 'Event Rate / Interaction' increases when the variant emerges.">Contagion Increase (%): <span id="variantContagionIncrease-value">25</span></label>
                    <input type="range" id="variantContagionIncrease" min="0" max="200" value="25" step="1">
                </div>
            </div>
            
            <div id="behavior" class="tab-content">
                <div class="control-group">
                    <label for="attractivenessChangeFreq" title="How many simulation steps pass before attractiveness values are updated.">Change Frequency (steps): <span id="attractivenessChangeFreq-value">100</span></label>
                    <input type="range" id="attractivenessChangeFreq" min="1" max="100" value="100" step="1">
                </div>
                <div class="control-group">
                    <label for="attractivenessChangePercent" title="The maximum percentage (plus or minus) that a point's attractiveness can change by during an update.">Change Range (%): <span id="attractivenessChangePercent-value">0</span></label>
                    <input type="range" id="attractivenessChangePercent" min="0" max="100" value="0" step="1">
                </div>
            </div>
        </div>
        
        <div class="button-group">
            <button id="startBtn">Start</button>
            <button id="togglePlayBtn" disabled>Pause</button>
            <button id="largeScaleBtn">Batch Run</button>
            <button id="exportBtn" disabled>Export Data</button>
        </div>
    </div>
    <div id="state-counts">
        <div>Day: <span id="count-day">0</span></div>
        <div><span class="color-indicator color-susceptible"></span>Susceptible: <span id="count-susceptible">0</span></div>
        <div><span class="color-indicator color-infectious"></span>Infectious: <span id="count-infectious">0</span></div>
        <div><span class="color-indicator color-hospitalized"></span>Hospitalized: <span id="count-hospitalized">0</span></div>
        <div><span class="color-indicator color-immune"></span>Immune: <span id="count-immune">0</span></div>
        <div><span class="color-indicator color-dead"></span>Dead: <span id="count-dead">0</span></div>
    </div>

    <!-- Large Scale Simulation Modal -->
    <div id="largeScaleModal" class="modal-overlay">
        <div class="modal">
            <h2>Large Scale Simulation</h2>
            <div class="control-group">
                <label for="numTrials">Number of Trials:</label>
                <input type="number" id="numTrials" value="100" min="1" max="10000">
            </div>
            <div class="control-group">
                <label>Export Format:</label>
                <div class="toggle-switch">
                    <input type="checkbox" id="exportTypeToggle" class="toggle-input">
                    <label for="exportTypeToggle" class="toggle-label">
                        <span class="toggle-text left">Average</span>
                        <span class="toggle-text right">Separated</span>
                    </label>
                </div>
            </div>
            <div id="progressBarContainer">
                <div id="progressBar">0%</div>
            </div>
            <p id="eta">ETA: Calculating...</p>
            <div class="modal-buttons">
                <button id="beginBatchBtn">Begin</button>
                <button id="cancelBatchBtn">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Core Setup ---
        let scene, camera, renderer;
        let points = [];
        let agents = [];
        let neighborMap = [];
        let simulationIntervalId;
        let isPaused = true;
        let isRunning = false;
        let config = {};
        let initialAgentCount = 0;
        let simulationData = [];
        let stepCount = 0;
        const MAX_DAYS = 1000;

        // --- DOM Elements ---
        const controls = {
            latticeSize: document.getElementById('latticeSize'),
            latticeSpacing: document.getElementById('latticeSpacing'),
            numAgents: document.getElementById('numAgents'),
            moveRadius: document.getElementById('moveRadius'),
            stayMultiplier: document.getElementById('stayMultiplier'),
            animDuration: document.getElementById('animDuration'),
            simInterval: document.getElementById('simInterval'),
            noiseFreq: document.getElementById('noiseFreq'),
            noiseExp: document.getElementById('noiseExp'),
            initialInfectious: document.getElementById('initialInfectious'),
            infectionProb: document.getElementById('infectionProb'),
            infEventRate: document.getElementById('infEventRate'),
            pI_S: document.getElementById('pI_S'),
            pI_H: document.getElementById('pI_H'),
            pI_D: document.getElementById('pI_D'),
            hospEventRate: document.getElementById('hospEventRate'),
            pH_S: document.getElementById('pH_S'),
            pH_D: document.getElementById('pH_D'),
            immunityDuration: document.getElementById('immunityDuration'),
            attractivenessChangeFreq: document.getElementById('attractivenessChangeFreq'),
            attractivenessChangePercent: document.getElementById('attractivenessChangePercent'),
            enableVariant: document.getElementById('enableVariant'),
            variantDay: document.getElementById('variantDay'),
            variantContagionIncrease: document.getElementById('variantContagionIncrease'),
            startBtn: document.getElementById('startBtn'),
            togglePlayBtn: document.getElementById('togglePlayBtn'),
            exportBtn: document.getElementById('exportBtn'),
            largeScaleBtn: document.getElementById('largeScaleBtn'),
            largeScaleModal: document.getElementById('largeScaleModal'),
            numTrials: document.getElementById('numTrials'),
            beginBatchBtn: document.getElementById('beginBatchBtn'),
            cancelBatchBtn: document.getElementById('cancelBatchBtn'),
            progressBar: document.getElementById('progressBar'),
            eta: document.getElementById('eta'),
            exportTypeToggle: document.getElementById('exportTypeToggle'),
        };
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const stateCounts = {
            day: document.getElementById('count-day'),
            susceptible: document.getElementById('count-susceptible'),
            infectious: document.getElementById('count-infectious'),
            hospitalized: document.getElementById('count-hospitalized'),
            immune: document.getElementById('count-immune'),
            dead: document.getElementById('count-dead')
        };

        /**
         * @description Binds all the event listeners for the UI controls. 
         * This includes sliders for parameter adjustment, tabs for navigating the UI, 
         * and the main start/pause/export buttons for simulation control.
         */
        function setupEventListeners() {
            Object.keys(controls).forEach(key => {
                if (controls[key] && controls[key].type === 'range') {
                    controls[key].addEventListener('input', () => {
                        const valueEl = document.getElementById(`${key}-value`);
                        if (valueEl) valueEl.textContent = controls[key].value;
                    });
                }
            });
            
            tabButtons.forEach(button => {
                button.addEventListener('click', () => {
                    tabButtons.forEach(btn => btn.classList.remove('active'));
                    tabContents.forEach(content => content.classList.remove('active'));
                    button.classList.add('active');
                    document.getElementById(button.dataset.tab).classList.add('active');
                });
            });

            controls.startBtn.addEventListener('click', startSimulation);
            controls.togglePlayBtn.addEventListener('click', togglePlay);
            controls.exportBtn.addEventListener('click', () => exportDataToCSV(simulationData, config, 'single'));
            controls.largeScaleBtn.addEventListener('click', () => controls.largeScaleModal.style.display = 'flex');
            controls.cancelBatchBtn.addEventListener('click', () => controls.largeScaleModal.style.display = 'none');
            controls.beginBatchBtn.addEventListener('click', runLargeScaleSimulation);

            const pI_sliders = [controls.pI_S, controls.pI_H, controls.pI_D];
            pI_sliders.forEach(slider => slider.addEventListener('input', () => balanceProbabilities(pI_sliders, document.getElementById('pI_M-value'), 'pI_M')));
            
            const pH_sliders = [controls.pH_S, controls.pH_D];
            pH_sliders.forEach(slider => slider.addEventListener('input', () => balanceProbabilities(pH_sliders, document.getElementById('pH_M-value'), 'pH_M')));
            
            balanceProbabilities(pI_sliders, document.getElementById('pI_M-value'), 'pI_M');
            balanceProbabilities(pH_sliders, document.getElementById('pH_M-value'), 'pH_M');
        }

        /**
         * @description Ensures a set of probability sliders sums to 1.
         * @param {HTMLInputElement[]} sliders - The array of sliders to balance.
         * @param {HTMLElement} remainderEl - The element to display the remaining probability.
         * @param {string} remainderSliderId - The ID of the disabled slider that shows the remainder.
         */
        function balanceProbabilities(sliders, remainderEl, remainderSliderId) {
            let total = sliders.reduce((sum, s) => sum + parseFloat(s.value), 0);
            if (total > 1) {
                const changedSlider = event.target;
                const excess = total - 1;
                let otherTotal = 0;
                sliders.forEach(s => { if (s !== changedSlider) otherTotal += parseFloat(s.value); });
                
                if (otherTotal > 0) {
                    sliders.forEach(s => {
                        if (s !== changedSlider) {
                            const proportion = parseFloat(s.value) / otherTotal;
                            s.value = parseFloat(s.value) - excess * proportion;
                            document.getElementById(`${s.id}-value`).textContent = parseFloat(s.value).toFixed(2);
                        }
                    });
                }
            }
            const remainder = 1 - sliders.reduce((sum, s) => sum + parseFloat(s.value), 0);
            const finalRemainder = Math.max(0, remainder);
            remainderEl.textContent = finalRemainder.toFixed(2);
            
            const remainderSlider = document.getElementById(remainderSliderId);
            if (remainderSlider) {
                remainderSlider.value = finalRemainder;
            }
        }

        /** @description Reads all values from the UI controls and stores them in the global config object. */
        function readConfig() {
            // Movement
            config.LATTICE_SIZE = parseInt(controls.latticeSize.value);
            config.LATTICE_SPACING = parseFloat(controls.latticeSpacing.value);
            config.NUM_AGENTS = parseInt(controls.numAgents.value);
            config.MOVE_RADIUS = parseFloat(controls.moveRadius.value);
            config.STAY_MULTIPLIER = parseFloat(controls.stayMultiplier.value);
            config.ANIMATION_DURATION = parseInt(controls.animDuration.value);
            config.SIMULATION_INTERVAL = parseInt(controls.simInterval.value);
            config.NOISE_FREQUENCY = parseFloat(controls.noiseFreq.value);
            config.NOISE_EXPONENT = parseFloat(controls.noiseExp.value);
            config.AGENT_SPREAD_RADIUS = 0.3;
            config.MAX_ATTRACTIVENESS = 10;
            
            // Infection
            config.INITIAL_INFECTIOUS_PERCENT = parseFloat(controls.initialInfectious.value) / 100;
            config.INFECTION_PROB = parseFloat(controls.infectionProb.value);
            config.INF_EVENT_RATE = parseFloat(controls.infEventRate.value);
            config.IMMUNITY_DURATION = parseInt(controls.immunityDuration.value);
            config.PI_S = parseFloat(controls.pI_S.value);
            config.PI_H = parseFloat(controls.pI_H.value);
            config.PI_D = parseFloat(controls.pI_D.value);
            config.PI_M = 1 - (config.PI_S + config.PI_H + config.PI_D);
            config.HOSP_EVENT_RATE = parseFloat(controls.hospEventRate.value);
            config.PH_S = parseFloat(controls.pH_S.value);
            config.PH_D = parseFloat(controls.pH_D.value);
            config.PH_M = 1 - (config.PH_S + config.PH_D);
            config.ENABLE_VARIANT = controls.enableVariant.checked;
            config.VARIANT_DAY = parseInt(controls.variantDay.value);
            config.VARIANT_CONTAGION_INCREASE = parseFloat(controls.variantContagionIncrease.value) / 100;


            // Behavior
            config.ATTRACTIVENESS_CHANGE_FREQ = parseInt(controls.attractivenessChangeFreq.value);
            config.ATTRACTIVENESS_CHANGE_PERCENT = parseFloat(controls.attractivenessChangePercent.value) / 100;

        }

        /** @description Removes all agents and points from the scene to prepare for a restart. */
        function cleanup() {
            if (simulationIntervalId) clearInterval(simulationIntervalId);
            agents.forEach(agent => scene.remove(agent.mesh));
            points.forEach(point => scene.remove(point.mesh));
            agents = [];
            points = [];
            neighborMap = [];
            simulationData = [];
            stepCount = 0;
        }

        /** * @description Starts or restarts the simulation with the current UI settings. */
        function startSimulation() {
            cleanup();
            readConfig();
            
            const aspect = window.innerWidth / window.innerHeight;
            const frustumSize = config.LATTICE_SIZE * config.LATTICE_SPACING;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();

            createLattice();
            precomputeNeighbors();
            createAgents();
            updateStateCounts();

            isPaused = false;
            isRunning = true;
            simulationIntervalId = setInterval(runSimulationTurn, config.SIMULATION_INTERVAL);
            
            controls.startBtn.textContent = 'Restart';
            controls.togglePlayBtn.disabled = false;
            controls.exportBtn.disabled = true;
            controls.togglePlayBtn.textContent = 'Pause';
        }

        /** * @description Initializes the THREE.js scene, camera, and renderer on page load. */
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 1000);
            camera.position.z = 10;
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);
            window.addEventListener('resize', onWindowResize, false);
        }

        /** * @description Creates the lattice of points with attractiveness values generated from Perlin noise. */
        function createLattice() {
            const noise = getNoiseHelper();
            noise.seed(Math.random());
            const pointGeometry = new THREE.RingGeometry(0.4, 0.5, 32);

            for (let i = 0; i < config.LATTICE_SIZE; i++) {
                for (let j = 0; j < config.LATTICE_SIZE; j++) {
                    const noiseValue = noise.perlin2(i / config.NOISE_FREQUENCY, j / config.NOISE_FREQUENCY);
                    const normalizedNoise = (noiseValue + 1) / 2;
                    const skewedNoise = Math.pow(normalizedNoise, config.NOISE_EXPONENT);
                    const attractiveness = Math.max(1, 0.1 * Math.round(10 * skewedNoise * (config.MAX_ATTRACTIVENESS - 1)) + 1);
                    const x = (i - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;
                    const y = (j - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;
                    
                    const mesh = new THREE.Mesh(pointGeometry.clone());
                    mesh.position.set(x, y, 0);

                    points.push({ 
                        x, y, attractiveness, mesh, index: points.length, 
                        isChanging: false, oldAttractiveness: attractiveness, changeStartTime: 0 
                    });
                    
                    updatePointVisuals(points[points.length-1]);
                    scene.add(mesh);
                }
            }
        }

        /** * @description Pre-calculates which points are within the move radius for every other point. */
        function precomputeNeighbors() {
            const maxDistance = config.MOVE_RADIUS * config.LATTICE_SPACING;
            for (let i = 0; i < points.length; i++) {
                const currentPoint = points[i];
                const nearbyPoints = [];
                for (let j = 0; j < points.length; j++) {
                    const otherPoint = points[j];
                    const distance = currentPoint.mesh.position.distanceTo(otherPoint.mesh.position);
                    if (distance <= maxDistance) {
                        nearbyPoints.push(otherPoint);
                    }
                }
                neighborMap[i] = nearbyPoints;
            }
        }

        /** * @description Creates the agents, sets their initial state, and infects a percentage of them. */
        function createAgents() {
            initialAgentCount = config.NUM_AGENTS;
            agents = [];
            const agentGeometry = new THREE.CircleGeometry(0.15, 16);
            for (let i = 0; i < config.NUM_AGENTS; i++) {
                const agentMaterial = new THREE.MeshBasicMaterial({ color: getAgentColor('susceptible')});
                const startPointIndex = Math.floor(Math.random() * points.length);
                const startPoint = points[startPointIndex];
                const mesh = new THREE.Mesh(agentGeometry, agentMaterial);
                mesh.position.copy(startPoint.mesh.position);
                scene.add(mesh);
                agents.push({ id: i, state: 'susceptible', currentPointIndex: startPointIndex, mesh, isMoving: false, moveStartTime: 0, startPosition: new THREE.Vector3(), endPosition: new THREE.Vector3(), immunityEndStep: -1 });
            }

            const numToInfect = Math.floor(config.NUM_AGENTS * config.INITIAL_INFECTIOUS_PERCENT);
            for (let i = 0; i < numToInfect; i++) {
                agents[i].state = 'infectious';
                agents[i].mesh.material.color.set(getAgentColor('infectious'));
            }
        }

        /** * @description The main simulation turn logic, running disease and movement logic sequentially. */
        function runSimulationTurn() {
            if (agents.some(a => a.isMoving) || points.some(p => p.isChanging)) return;

            // Phase A: Disease and State Changes at rest
            const agentsByPoint = {};
            agents.forEach(agent => {
                if (!agentsByPoint[agent.currentPointIndex]) {
                    agentsByPoint[agent.currentPointIndex] = [];
                }
                agentsByPoint[agent.currentPointIndex].push(agent);
            });
            
            // Variant emergence logic
            if (config.ENABLE_VARIANT && stepCount === config.VARIANT_DAY) {
                config.INFECTION_PROB *= (1 + config.VARIANT_CONTAGION_INCREASE);
                agents.forEach(agent => {
                    if (agent.state === 'immune') {
                        agent.state = 'susceptible';
                    }
                });
            }

            Object.values(agentsByPoint).forEach(group => {
                const infectiousCount = group.filter(a => a.state === 'infectious').length;
                if (infectiousCount > 0) {
                    group.forEach(agent => {
                        if (agent.state === 'susceptible' && Math.random() < config.INFECTION_PROB) {
                            agent.state = 'infectious';
                        }
                    });
                }
            });

            const agentsToRemove = new Set();
            agents.forEach(agent => {
                let newState = agent.state;
                if (agent.state === 'infectious' && Math.random() < config.INF_EVENT_RATE) {
                    newState = determineNextState(agent, 'infectious');
                } else if (agent.state === 'hospitalized' && Math.random() < config.HOSP_EVENT_RATE) {
                    newState = determineNextState(agent, 'hospitalized');
                } else if (agent.state === 'immune' && stepCount >= agent.immunityEndStep) {
                    newState = 'susceptible';
                }
                
                if(newState === 'immune' && agent.state !== 'immune') {
                    agent.immunityEndStep = stepCount + getPoissonRandom(config.IMMUNITY_DURATION);
                }
                agent.state = newState;

                if (agent.state === 'dead') agentsToRemove.add(agent);
            });

            // Phase B: Plan and Initiate Movement
            agents.forEach(agent => {
                if (agent.state === 'dead') return;
                agent.mesh.material.color.set(getAgentColor(agent.state));
                if (agent.state !== 'hospitalized') {
                    moveAgent(agent);
                }
            });

            if (agentsToRemove.size > 0) {
                agentsToRemove.forEach(agent => scene.remove(agent.mesh));
                agents = agents.filter(a => !agentsToRemove.has(a));
            }

            // Phase C: Update Attractiveness
            if (stepCount > 0 && stepCount % config.ATTRACTIVENESS_CHANGE_FREQ === 0) {
                updateAttractiveness();
            }
            
            updateStateCounts();
        }
        
        /**
         * @description Updates the attractiveness of all points on the grid based on the configured settings.
         */
        function updateAttractiveness() {
            points.forEach(point => {
                point.isChanging = true;
                point.oldAttractiveness = point.attractiveness;
                point.changeStartTime = performance.now();
                
                const changePercent = (Math.random() * 2 - 1) * config.ATTRACTIVENESS_CHANGE_PERCENT;
                const newAttractiveness = point.attractiveness * (1 + changePercent);
                point.attractiveness = Math.max(1, Math.min(newAttractiveness, config.MAX_ATTRACTIVENESS)); // Clamp between 1 and max
            });
        }
        
        /**
         * @description Updates the visual properties (color and scale) of a point.
         * @param {object} point - The point object to update.
         * @param {number} [attractivenessOverride] - Optional value to override the point's current attractiveness for interpolation.
         */
        function updatePointVisuals(point, attractivenessOverride) {
            const attractiveness = attractivenessOverride !== undefined ? attractivenessOverride : point.attractiveness;
            const lightness = 0.5 + 0.5 * (attractiveness / config.MAX_ATTRACTIVENESS);
            const color = new THREE.Color().setHSL(0, 0, lightness);
            
            point.mesh.material.color.copy(color);
            point.mesh.scale.set(attractiveness * 0.5, attractiveness * 0.5, 1);
        }

        /** * @description For a given agent state, determines the next state based on configured probabilities. */
        function determineNextState(agent, currentState) {
            const r = Math.random();
            if (currentState === 'infectious') {
                if (r < config.PI_S) return 'susceptible';
                if (r < config.PI_S + config.PI_H) return 'hospitalized';
                if (r < config.PI_S + config.PI_H + config.PI_D) return 'dead';
                return 'immune';
            }
            if (currentState === 'hospitalized') {
                if (r < config.PH_S) return 'susceptible';
                if (r < config.PH_S + config.PH_D) return 'dead';
                return 'immune';
            }
            return currentState;
        }

        /** * @description Calculates the next destination for an agent and initiates its movement. */
        function moveAgent(agent) {
             const potentialDestinations = neighborMap[agent.currentPointIndex];
            if (!potentialDestinations || potentialDestinations.length === 0) return;
            
            const weightedDestinations = [];
            let totalRelativeAttractiveness = 0;
            potentialDestinations.forEach(point => {
                const distance = points[agent.currentPointIndex].mesh.position.distanceTo(point.mesh.position);
                const isStationary = distance < 0.01;
                const relativeAttractiveness = isStationary ? config.STAY_MULTIPLIER * point.attractiveness : point.attractiveness / Math.max(0.001, Math.pow(distance, 2));
                weightedDestinations.push({ point, relativeAttractiveness });
                totalRelativeAttractiveness += relativeAttractiveness;
            });

            let randomValue = Math.random() * totalRelativeAttractiveness;
            let chosenDestination = potentialDestinations[0]; 
            for (const dest of weightedDestinations) {
                randomValue -= dest.relativeAttractiveness;
                if (randomValue <= 0) {
                    chosenDestination = dest.point;
                    break;
                }
            }

            const targetPosition = chosenDestination.mesh.position.clone();
            const angle = Math.random() * 2 * Math.PI;
            const radius = Math.random() * config.AGENT_SPREAD_RADIUS;
            targetPosition.x += Math.cos(angle) * radius;
            targetPosition.y += Math.sin(angle) * radius;

            agent.isMoving = true;
            agent.moveStartTime = performance.now();
            agent.startPosition.copy(agent.mesh.position);
            agent.endPosition.copy(targetPosition);
            agent.currentPointIndex = chosenDestination.index;
        }

        /** * @description Returns the appropriate THREE.Color for an agent's state. */
        function getAgentColor(state) {
            switch(state) {
                case 'susceptible': return new THREE.Color('hsl(216, 80%, 50%)');
                case 'infectious': return new THREE.Color('hsl(0, 100%, 50%)');
                case 'hospitalized': return new THREE.Color('hsl(36, 80%, 60%)');
                case 'immune': return new THREE.Color('hsl(0, 0%, 80%)');
                default: return new THREE.Color('black');
            }
        }
        
        /** * @description The main animation loop, which runs every frame to render the scene. */
        function animate() {
            requestAnimationFrame(animate);
            const now = performance.now();
            
            // Agent movement animation
            agents.forEach(agent => {
                if (agent.isMoving) {
                    const elapsedTime = now - agent.moveStartTime;
                    const progress = Math.min(elapsedTime / config.ANIMATION_DURATION, 1.0);
                    const easedProgress = progress * progress * (3 - 2 * progress);
                    agent.mesh.position.lerpVectors(agent.startPosition, agent.endPosition, easedProgress);
                    if (progress >= 1.0) {
                        agent.isMoving = false;
                        agent.mesh.position.copy(agent.endPosition);
                    }
                }
            });

            // Point attractiveness change animation
            points.forEach(point => {
                if (point.isChanging) {
                    const elapsedTime = now - point.changeStartTime;
                    const progress = Math.min(elapsedTime / (config.SIMULATION_INTERVAL / 2), 1.0);
                    const easedProgress = progress * progress * (3 - 2 * progress);
                    
                    const newAttractiveness = THREE.MathUtils.lerp(point.oldAttractiveness, point.attractiveness, easedProgress);
                    updatePointVisuals(point, newAttractiveness);

                    if (progress >= 1.0) {
                        point.isChanging = false;
                        updatePointVisuals(point); // Snap to final value
                    }
                }
            });

            renderer.render(scene, camera);
        }

        /** * @description Updates the state counters in the UI legend and stores the data for export. */
        function updateStateCounts() {
            stepCount++;
            const counts = { S: 0, I: 0, H: 0, M: 0 };
            agents.forEach(agent => {
                if (agent.state === 'susceptible') counts.S++;
                else if (agent.state === 'infectious') counts.I++;
                else if (agent.state === 'hospitalized') counts.H++;
                else if (agent.state === 'immune') counts.M++;
            });
            
            const deadCount = initialAgentCount - agents.length;
            
            stateCounts.day.textContent = stepCount;
            stateCounts.susceptible.textContent = counts.S;
            stateCounts.infectious.textContent = counts.I;
            stateCounts.hospitalized.textContent = counts.H;
            stateCounts.immune.textContent = counts.M;
            stateCounts.dead.textContent = deadCount;
            
            const prop = (count) => (initialAgentCount > 0 ? count / initialAgentCount : 0);
            simulationData.push({ Day: stepCount, S: prop(counts.S), I: prop(counts.I), H: prop(counts.H), M: prop(counts.M), D: prop(deadCount) });

            if (counts.I === 0 && counts.H === 0 && isRunning && !isPaused) {
                togglePlay();
            }
        }

        /** * @description Handles window resizing to keep the camera and renderer updated. */
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            camera.aspect = aspect;
            const frustumSize = (config && config.LATTICE_SIZE) ? config.LATTICE_SIZE * config.LATTICE_SPACING : 20;
            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        /** * @description Toggles the paused state of the simulation. */
        function togglePlay() {
            if (!isRunning) return;
            isPaused = !isPaused;
            if (isPaused) {
                clearInterval(simulationIntervalId);
                controls.togglePlayBtn.textContent = "Resume";
                controls.exportBtn.disabled = false;
            } else {
                simulationIntervalId = setInterval(runSimulationTurn, config.SIMULATION_INTERVAL);
                controls.togglePlayBtn.textContent = "Pause";
                controls.exportBtn.disabled = true;
            }
        }

        /** * @description Compiles simulation data and parameters into a CSV file and triggers a download. */
        function exportDataToCSV(data, simConfig, type) {
            let csvContent = "";
            
            csvContent += "# Simulation Parameters\n";
            for(const key in simConfig) {
                csvContent += `# ${key},${simConfig[key]}\n`;
            }
            csvContent += "\n";
            
            if (type === 'batch_separated') {
                data.forEach((trialData, index) => {
                    csvContent += `# Trial ${index + 1}\n`;
                    csvContent += "Day,S,I,H,M,D\n";
                    trialData.forEach(row => {
                         csvContent += `${row.Day},${row.S.toFixed(4)},${row.I.toFixed(4)},${row.H.toFixed(4)},${row.M.toFixed(4)},${row.D.toFixed(4)}\n`;
                    });
                    csvContent += "\n";
                });
            } else { // 'single' or 'batch_average'
                csvContent += "Day,S,I,H,M,D\n";
                data.forEach(row => {
                    const s = typeof row.S === 'number' ? row.S.toFixed(4) : row.S;
                    const i = typeof row.I === 'number' ? row.I.toFixed(4) : row.I;
                    const h = typeof row.H === 'number' ? row.H.toFixed(4) : row.H;
                    const m = typeof row.M === 'number' ? row.M.toFixed(4) : row.M;
                    const d = typeof row.D === 'number' ? row.D.toFixed(4) : row.D;
                    csvContent += `${row.Day},${s},${i},${h},${m},${d}\n`;
                });
            }


            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            link.setAttribute("download", `sihmd_${type}_${timestamp}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        /**
         * @description Generates a random number from a Poisson distribution.
         * @param {number} mean - The mean (lambda) of the distribution.
         * @returns {number} A random integer.
         */
        function getPoissonRandom(mean) {
            let L = Math.exp(-mean);
            let k = 0;
            let p = 1;
            do {
                k++;
                p *= Math.random();
            } while (p > L);
            return k - 1;
        }

        /**
         * @description Runs a "headless" version of the simulation without visuals for batch processing.
         * @returns {Promise<object[]>} A promise that resolves with the simulation data for one trial.
         */
        async function runHeadlessTrial() {
            let trialAgents = [];
            const trialPoints = [];
            const trialNeighborMap = [];
            const trialSimulationData = [];
            let trialStepCount = 0;
            let localInfectionProb = config.INFECTION_PROB; // Use a local copy for the trial
            
            // Re-create lattice data without meshes
            const noise = getNoiseHelper();
            noise.seed(Math.random());
            for (let i = 0; i < config.LATTICE_SIZE; i++) {
                for (let j = 0; j < config.LATTICE_SIZE; j++) {
                    const noiseValue = noise.perlin2(i / config.NOISE_FREQUENCY, j / config.NOISE_FREQUENCY);
                    const normalizedNoise = (noiseValue + 1) / 2;
                    const skewedNoise = Math.pow(normalizedNoise, config.NOISE_EXPONENT);
                    const attractiveness = Math.max(1, 0.1 * Math.round(10 * skewedNoise * (config.MAX_ATTRACTIVENESS - 1)) + 1);
                    const x = (i - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;
                    const y = (j - (config.LATTICE_SIZE - 1) / 2) * config.LATTICE_SPACING;
                    trialPoints.push({ x, y, attractiveness, index: trialPoints.length, mesh: { position: new THREE.Vector3(x, y, 0) } });
                }
            }

            // Re-create neighbor map
            const maxDistance = config.MOVE_RADIUS * config.LATTICE_SPACING;
            for (let i = 0; i < trialPoints.length; i++) {
                const currentPoint = trialPoints[i];
                const nearbyPoints = [];
                for (let j = 0; j < trialPoints.length; j++) {
                    const otherPoint = trialPoints[j];
                    const distance = currentPoint.mesh.position.distanceTo(otherPoint.mesh.position);
                    if (distance <= maxDistance) nearbyPoints.push(otherPoint);
                }
                trialNeighborMap[i] = nearbyPoints;
            }

            // Create agents
            const numToInfect = Math.floor(config.NUM_AGENTS * config.INITIAL_INFECTIOUS_PERCENT);
            for (let i = 0; i < config.NUM_AGENTS; i++) {
                const startPointIndex = Math.floor(Math.random() * trialPoints.length);
                trialAgents.push({ id: i, state: i < numToInfect ? 'infectious' : 'susceptible', currentPointIndex: startPointIndex, immunityEndStep: -1 });
            }
            
            // Run headless simulation loop
            let isAtEquilibrium = false;
            while(!isAtEquilibrium && trialStepCount < MAX_DAYS) { // Safety break
                trialStepCount++;
                if (config.ENABLE_VARIANT && trialStepCount === config.VARIANT_DAY) {
                    localInfectionProb *= (1 + config.VARIANT_CONTAGION_INCREASE);
                    trialAgents.forEach(agent => {
                        if (agent.state === 'immune') {
                            agent.state = 'susceptible';
                        }
                    });
                }
                const agentsByPoint = {};
                trialAgents.forEach(agent => {
                    if (!agentsByPoint[agent.currentPointIndex]) agentsByPoint[agent.currentPointIndex] = [];
                    agentsByPoint[agent.currentPointIndex].push(agent);
                });

                Object.values(agentsByPoint).forEach(group => {
                    const infectiousCount = group.filter(a => a.state === 'infectious').length;
                    if (infectiousCount > 0) {
                        group.forEach(agent => {
                            if (agent.state === 'susceptible' && Math.random() < localInfectionProb) {
                                agent.state = 'infectious';
                            }
                        });
                    }
                });

                const agentsToRemove = new Set();
                trialAgents.forEach(agent => {
                    let newState = agent.state;
                    if (agent.state === 'infectious' && Math.random() < config.INF_EVENT_RATE) {
                        newState = determineNextState(agent, 'infectious');
                    } else if (agent.state === 'hospitalized' && Math.random() < config.HOSP_EVENT_RATE) {
                        newState = determineNextState(agent, 'hospitalized');
                    } else if (agent.state === 'immune' && trialStepCount >= agent.immunityEndStep) {
                        newState = 'susceptible';
                    }
                    
                    if(newState === 'immune' && agent.state !== 'immune') {
                        agent.immunityEndStep = trialStepCount + getPoissonRandom(config.IMMUNITY_DURATION);
                    }
                    agent.state = newState;

                    if (agent.state === 'dead') agentsToRemove.add(agent);
                });

                if (agentsToRemove.size > 0) {
                    trialAgents = trialAgents.filter(a => !agentsToRemove.has(a));
                }

                // Simplified movement
                trialAgents.forEach(agent => {
                    if (agent.state !== 'hospitalized') {
                        const potentialDests = trialNeighborMap[agent.currentPointIndex];
                        if (potentialDests && potentialDests.length > 0) {
                             let totalAttractiveness = 0;
                             potentialDests.forEach(p => totalAttractiveness += p.attractiveness);
                             let randomVal = Math.random() * totalAttractiveness;
                             for(const p of potentialDests) {
                                 randomVal -= p.attractiveness;
                                 if(randomVal <= 0) {
                                     agent.currentPointIndex = p.index;
                                     break;
                                 }
                             }
                        }
                    }
                });
                
                const counts = { S: 0, I: 0, H: 0, M: 0 };
                trialAgents.forEach(agent => {
                    if (agent.state === 'susceptible') counts.S++;
                    else if (agent.state === 'infectious') counts.I++;
                    else if (agent.state === 'hospitalized') counts.H++;
                    else if (agent.state === 'immune') counts.M++;
                });

                const deadCount = config.NUM_AGENTS - trialAgents.length;
                const prop = (count) => (config.NUM_AGENTS > 0 ? (count / config.NUM_AGENTS) : 0);
                trialSimulationData.push({ Day: trialStepCount, S: prop(counts.S), I: prop(counts.I), H: prop(counts.H), M: prop(counts.M), D: prop(deadCount) });
                if(counts.I === 0 && counts.H === 0) isAtEquilibrium = true;
            }
            return trialSimulationData;
        }

        /** @description Runs a batch of headless simulations and exports the averaged results. */
        async function runLargeScaleSimulation() {
            controls.beginBatchBtn.disabled = true;
            controls.cancelBatchBtn.textContent = "Cancel";

            readConfig();
            const numTrials = parseInt(controls.numTrials.value);
            const allTrialsData = [];
            const startTime = performance.now();

            for (let i = 0; i < numTrials; i++) {
                const trialData = await runHeadlessTrial();
                allTrialsData.push(trialData);
                
                const progress = ((i + 1) / numTrials) * 100;
                controls.progressBar.style.width = `${progress}%`;
                controls.progressBar.textContent = `${Math.round(progress)}%`;

                const timeElapsed = performance.now() - startTime;
                const timePerTrial = timeElapsed / (i + 1);
                const remainingTrials = numTrials - (i + 1);
                const etaSeconds = Math.round(timePerTrial * remainingTrials / 1000);
                controls.eta.textContent = `ETA: ${etaSeconds} seconds`;
                
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            if (controls.exportTypeToggle.checked) {
                exportDataToCSV(allTrialsData, config, 'batch_separated');
            } else {
                const averagedData = averageSimulationResults(allTrialsData, config);
                exportDataToCSV(averagedData, config, 'batch_average');
            }

            controls.largeScaleModal.style.display = 'none';
            controls.beginBatchBtn.disabled = false;
        }

        /**
         * @description Averages the results from multiple simulation trials.
         * @param {Array<Array<Object>>} allTrialsData - An array where each element is the data array from one trial.
         * @param {object} currentConfig - The configuration object for the batch run.
         * @returns {Array<Object>} The averaged data, with one row per day.
         */
        function averageSimulationResults(allTrialsData, currentConfig) {
            const prop = (count) => (currentConfig.NUM_AGENTS > 0 ? (count / currentConfig.NUM_AGENTS) : 0);
            const averagedResults = [{
                Day: 0,
                S: (1 - currentConfig.INITIAL_INFECTIOUS_PERCENT),
                I: currentConfig.INITIAL_INFECTIOUS_PERCENT,
                H: 0,
                M: 0,
                D: 0
            }];
            
            const aggregatedData = {};
            let maxDays = 0;

            allTrialsData.forEach(trial => {
                if (trial.length > maxDays) maxDays = trial.length;
                trial.forEach(dayData => {
                    if (!aggregatedData[dayData.Day]) {
                        aggregatedData[dayData.Day] = { S: 0, I: 0, H: 0, M: 0, D: 0, count: 0 };
                    }
                    aggregatedData[dayData.Day].S += dayData.S;
                    aggregatedData[dayData.Day].I += dayData.I;
                    aggregatedData[dayData.Day].H += dayData.H;
                    aggregatedData[dayData.Day].M += dayData.M;
                    aggregatedData[dayData.Day].D += dayData.D;
                });
            });

            for (let day = 1; day <= maxDays; day++) {
                 allTrialsData.forEach(trial => {
                     if (trial[day-1]) {
                         if (!aggregatedData[day]) { 
                             aggregatedData[day] = { S: 0, I: 0, H: 0, M: 0, D: 0, count: 0 };
                         }
                         aggregatedData[day].count++;
                     }
                 });
            }

            for (let day = 1; day <= maxDays; day++) {
                const dayData = aggregatedData[day];
                if (dayData && dayData.count > 0) {
                     averagedResults.push({
                         Day: day,
                         S: dayData.S / dayData.count,
                         I: dayData.I / dayData.count,
                         H: dayData.H / dayData.count,
                         M: dayData.M / dayData.count,
                         D: dayData.D / dayData.count
                     });
                }
            }
            return averagedResults;
        }
        
        /** * @description Generates Perlin noise values for creating the attractiveness landscape. */
        function getNoiseHelper() {
            class Grad { constructor(x, y, z) { this.x = x; this.y = y; this.z = z; } dot2(x, y) { return this.x * x + this.y * y; } }
            const grad3 = [ new Grad(1, 1, 0), new Grad(-1, 1, 0), new Grad(1, -1, 0), new Grad(-1, -1, 0), new Grad(1, 0, 1), new Grad(-1, 0, 1), new Grad(1, 0, -1), new Grad(-1, 0, -1), new Grad(0, 1, 1), new Grad(0, -1, 1), new Grad(0, 1, -1), new Grad(0, -1, -1) ];
            const p = [ 151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180 ];
            let perm = new Array(512), gradP = new Array(512);
            function seed(s) { if(s>0&&s<1)s*=65536; s=Math.floor(s); if(s<256)s|=s<<8; for(let i=0;i<256;i++){let v=(i&1)?p[i]^(s&255):p[i]^((s>>8)&255);perm[i]=perm[i+256]=v;gradP[i]=gradP[i+256]=grad3[v%12]}}
            seed(0);
            function fade(t){return t*t*t*(t*(t*6-15)+10)} function lerp(a,b,t){return(1-t)*a+t*b}
            function perlin2(x, y) { let X=Math.floor(x),Y=Math.floor(y);x=x-X;y=y-Y;X=X&255;Y=Y&255;let n00=gradP[X+perm[Y]].dot2(x,y);let n01=gradP[X+perm[Y+1]].dot2(x,y-1);let n10=gradP[X+1+perm[Y]].dot2(x-1,y);let n11=gradP[X+1+perm[Y+1]].dot2(x-1,y-1);let u=fade(x);return lerp(lerp(n00,n10,u),lerp(n01,n11,u),fade(y))}
            return { seed, perlin2 };
        }

        // --- Start Application ---
        init();
        setupEventListeners();
        animate();

    </script>
</body>
</html>
